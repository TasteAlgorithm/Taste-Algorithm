## 题目地址

- [地址](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

## 题目描述

```
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思路

## 关键点解析

- 深度优先搜索

## 代码

- 语言支持：Python，Java，JS

Python Code:

```python
class Solution:
    #用快慢双指针来确定中间节点，prev负责断开mid左边节点
    def findmid(self, head):

        # The pointer used to disconnect the left half from the mid node.
        slowPtr = head
        fastPtr = head
        prevPtr = None

        # Iterate until fastPr doesn't reach the end of the linked list.
        while fastPtr and fastPtr.next:
            prevPtr = slowPtr
            slowPtr = slowPtr.next
            fastPtr = fastPtr.next.next

        if prevPtr:
            prevPtr.next=None
        
        return slowPtr


    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        # If the head doesn't exist, then the linked list is empty
        if not head:
            return None
        # Find the middle element for the list.
        mid = self.findmid(head)
        # The mid becomes the root of the BST.
        node = TreeNode(mid.val)
        # Base case when there is just one element in the linked list
        if head == mid:
            return node
        # Recursively form balanced BSTs using the left and right halves of the original list.
        node.left = self.sortedListToBST(head)
        node.right = self.sortedListToBST(mid.next)
        return node


```

Java Code:

```java
/**
* 高度平衡意味着每次必须选择中间数字作为根节点，这对于奇数个数的数组是有用的
* 对于偶数个数的数组，要么选择中间位置左边的元素作为根节点，要么选择中间位置右边的元素作为根节点，
* 不同的选择方案会创建不同的平衡二叉搜索树。两种方法都是可以的
*/
class Solution {
    private ListNode node;
    public TreeNode sortedListToBST(ListNode head) {
        int n = 0;
        node = head;
        while(head != null){
            head = head.next;
            n++;
        }
        return toBST(0, n-1);
    }
    private TreeNode toBST(int left, int right){
        if(left > right) return null;
        int m = (left + right) / 2;
        TreeNode left_child = toBST(left, m-1);
        TreeNode father = new TreeNode(node.val);
        node = node.next;
        father.left = left_child;
        father.right = toBST(m+1, right);
        return father;
    }
}
```

Javascript Code:

```js
var sortedListToBST = function(head) {
  if (!head) {
    return null;
  }
  return helper(head, null);
};
var helper = function(head, tail) {
  if (head === tail) {
    return null;
  }
  let slow = head;
  let fast = head;
  while (fast !== tail && fast.next !== tail) {
    fast = fast.next.next;
    slow = slow.next;
  }
  let root = new TreeNode(slow.val);
  root.left = helper(head, slow);
  root.right = helper(slow.next, tail);
  return root;
};
// sortedListToBST([-10, -3, 0, 5, 9]);debugger test
```

## 扩展
